1. ssh-copy-id user@ip_adress - Скопировать ключ ssh на удалённый сервер                                                                        2. Флаг -i - Указание конкретного ключа         ssh-copy-id -i ~/.ssh/id_255519-keyname user@ip_adress

3. echo $PATH
Что делает: Выводит значение переменной окружения PATH

Что такое PATH:

Это список каталогов, разделенных двоеточиями (:)

Когда вы вводите команду (например, ls), система ищет исполняемый файл в этих каталогах по порядку

Пример вывода:

```
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Зачем нужно:

Быстро проверить, в каких каталогах система ищет программы

Убедиться, что каталог с вашей программой добавлен в PATH

Отладка проблем "команда не найдена" (command not found)

4. echo "a b" | wc -w и echo 'a b' | wc -w
Обе команды делают одно и то же, но с разными типами кавычек.

Разбор по частям:

echo - выводит текст в консоль

"a b" и 'a b' - строка с пробелом между 'a' и 'b'

Разница в кавычках:

Двойные ": Интерпретируют переменные и специальные символы

Одинарные ': Выводят текст буквально, без интерпретации

Пример разницы:

```
echo "Сегодня $(date)"  # Выведет: Сегодня Tue Feb  8 12:34:56 UTC 2024
echo 'Сегодня $(date)'  # Выведет: Сегодня $(date)
```

| (пайп, конвейер)

Перенаправляет вывод одной команды на вход другой

echo "a b" → выводит "a b" → передает эту строку в wc -w

wc -w

wc = word count (подсчет слов)

-w = флаг для подсчета только слов (words)

Считает количество слов, разделенных пробелами/табуляцией/новой строкой

Небольшое демо:

```
# Демонстрация wc
echo "a b" | wc -w      # Вывод: 2
echo "hello world" | wc -w  # Вывод: 2
echo "один два три" | wc -w  # Вывод: 3

# Разница между кавычками с переменной
MYVAR="значение"
echo "$MYVAR"  # Вывод: значение
echo '$MYVAR'  # Вывод: $MYVAR
```

Полезные варианты wc:

```
echo "a b c" | wc        # Полная статистика: строки/слова/символы
# Пример вывода: 1  3  6
# 1 строка, 3 слова, 6 символов (включая пробелы)

echo "a b c" | wc -l     # Только строки
echo "a b c" | wc -c     # Только символы (байты)
echo "a b c" | wc -m     # Только символы (unicode)
```

Практическое применение:

```
# Подсчет слов в файле
wc -w document.txt

# Сколько пользователей в системе (подсчет строк)
who | wc -l

# Сколько процессов запущено от текущего пользователя
ps aux | grep $USER | wc -l

# Проверка длины PATH (сколько каталогов)
echo $PATH | tr ':' '\n' | wc -l
```

5. set -u (или set -o nounset)
Что делает: Запрещает использование необъявленных переменных.

Пример без set -u:

```
# Без set -u
echo "Hello $USERNAME"  # Если USERNAME не объявлена, просто выведет "Hello "
echo "Продолжаем выполнение..."
```

Пример с set -u:

```
# С set -u
set -u
echo "Hello $USERNAME"  # ОШИБКА: USERNAME: unbound variable
echo "Эта строка не выполнится"
```

Поведение:

```
# Пример 1: Нормальная работа с объявленной переменной
name="Иван"
set -u
echo "Привет, $name"  # OK: Привет, Иван

# Пример 2: Ошибка при использовании необъявленной переменной
set -u
echo "Путь: $PATH_TO_SOMETHING"  # Ошибка: PATH_TO_SOMETHING: unbound variable
```

Зачем нужно:
Обнаружение опечаток в именах переменных

Предотвращение скрытых ошибок, когда переменная пуста

Повышение безопасности скриптов

Отключение:

```
set +u  # Отключает проверку
```

set -o pipefail (только в bash)
Что делает: Изменяет поведение конвейеров (pipes) - возвращает код ошибки последней команды в конвейере, которая завершилась с ошибкой.

Стандартное поведение (без pipefail):

```
# Команда1 | Команда2 | Команда3
# $? (статус) = статус Команда3, даже если Команда1 или Команда2 упали

ls несуществующий_файл | sort  # ls завершится с ошибкой
echo $?  # Выведет 0 (успех!), потому что sort выполнился успешно
```

С set -o pipefail:

```
set -o pipefail
ls несуществующий_файл | sort  # ls завершится с ошибкой
echo $?  # Выведет НЕ 0 (2 - код ошибки ls)
```

Подробный пример:

```
#!/bin/bash

# Без pipefail
echo "Тест 1 (без pipefail):"
ls /несуществующий | head -5
echo "Статус: $?"  # 0 (head успешен)

echo -e "\nТест 2 (с pipefail):"
set -o pipefail
ls /несуществующий | head -5
echo "Статус: $?"  # 2 (ошибка ls)
```

Практическое применение:

```
#!/bin/bash
set -o pipefail

# Если какая-то команда в пайплайне упадет, весь скрипт узнает об этом
curl -s https://api.example.com/data | jq '.items' | head -10

if [ $? -ne 0 ]; then
    echo "Ошибка в получении данных!"
    exit 1
fi
```

Отключение:

```
set +o pipefail  # Возвращает стандартное поведение
```

Часто используемые вместе:

```
#!/bin/bash
# Строгий режим для скриптов
set -euo pipefail

# Расшифровка:
# -e: exit on error (выход при любой ошибке)
# -u: nounset (ошибка при использовании необъявленных переменных)
# -o pipefail: ошибка пайплайна, если ошибка в любой его части
```

Полный пример надёжного скрипта:

```
#!/bin/bash
set -euo pipefail

# Теперь скрипт:
# 1. Выйдет при любой ошибке
# 2. Не позволит использовать необъявленные переменные
# 3. Будет считать пайплайн неудачным, если ошибка в любом месте цепочки

# Пример безопасной обработки
input_file="${1:-}"  # Используем значение по умолчанию для безопасного использования с -u
if [ -z "$input_file" ]; then
    echo "Укажите файл" >&2
    exit 1
fi

# Безопасная обработка
grep "ERROR" "$input_file" | sort -u | head -20
# Если grep не найдет файл (ошибка) или любой другой этап упадет,
# весь скрипт завершится с ненулевым кодом
```

Предупреждение для интерактивного режима:

```
# В интерактивной оболочке set -u может быть неудобен:
set -u
echo $SOME_VAR  # Ошибка, если переменная не задана
cd $SOME_DIR    # Ошибка, если переменная не задана

# Поэтому обычно его используют только в скриптах
# или отключают после использования:
set +u
```

